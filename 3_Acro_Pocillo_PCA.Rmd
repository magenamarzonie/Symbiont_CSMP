---
title: "3_Acro_Pocillo_PCA"
author: "Magena Marzonie"
date: "09/02/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#Load libraries 
```{r}
library(vegan)
library(ggsci)
library(tidyverse)
library(kmer)
library(phangorn)
library(GUniFrac)
library(ggtree)
library(patchwork)
library(bioseq)
library(ape)
library(Biostrings)
select = dplyr::select
```

#Load data 
```{r}
#load environmental data 
load("Data/SiteDisturbanceHistory_DHW.RData")
load("Data/SiteDisturbanceHistory_DHW.RData")

#load seq data from 2_UPGMA
load("Data/du_acro.RData")
load("Data/du_poci.RData")
load("Data/du_pver.Rdata")
load("Data/du_pmea.Rdata")
load("Data/du_punk.Rdata")
load("Data/full_meta.RData")
load("Data/full_meta2.RData")
```

#Data Wrangle 
```{r}
#Combining symbiont unifrac distances and environmental metadata
full_meta2 = full_meta2 %>% 
  mutate(DHW = as.numeric(DHW),
         Reef = as.factor(Reef.x),
         Site = as.factor(Site),
         Exposure = as.factor(Exposure),
         catBleaching = as.factor(catBleaching),
         Aspect = as.factor(Aspect))
```

# ----------------------------------------------------------
Permanova/ PCoA: **Pocillopora verrucosa**
# ----------------------------------------------------------

Workflow for each host species: 
1) Test VIF scores and remove any with VIF score > 3 
2) Unconstrained dbRDA to test all environmental factors 
3) Select environmental variables of interest 
4) Run constrained dbRDA on important enviro factors
5) Plot constrained dbRDA using either nMDS or PCoA 


**P. verrucosa**
```{r}
#importing unifrac distances for analysis 
dist_pver <- as.dist(du_pver, diag = FALSE)
dim(du_pver)

adonis_meta_pver <- full_meta2 %>%
  dplyr::select(plate_position, Sector, Reef.x, Site, Species, 
                catBleaching, Depth, DHW, GPS_S = `GPS south`, 
                GPS_E = `GPS east`, Aspect, Exposure, maxDHW, 
                meanDHW, recent.maxDHW, recent.meanDHW, DHW2, 
                DHW3, DHW4, DHW6, DHW8, DHW9, returnDHW3, returnDHW4, 
                returnDHW6, rangeSST, varSST, MMM) %>%
  filter(plate_position %in% rownames(du_pver)) %>%
  tibble::column_to_rownames(var = "plate_position") %>%
  mutate(sample_name = rownames(.))

# NOTE: Need to make sure there are no alias factors. E.g. exposure is an alias of Reef (e.g. all Marion = Exposed, Site and Reef contain aliases, DHW2 == DHW3, etc)


# Make a correlation matrix of numeric variables
cm_pver <- cor(adonis_meta_pver %>% select(Depth, maxDHW, meanDHW, recent.maxDHW, 
                                      recent.meanDHW, DHW3, DHW4, DHW6, DHW8, 
                                      DHW9, rangeSST, varSST, MMM, GPS_S))
library(corrplot)
corrplot(cm_pver) # Clearly a lot of the DHW terms are positively related and approaching redundant

# Check the vif scores of the full model
ord_pver_full <- dbrda(dist_pver ~  Depth + maxDHW + meanDHW + recent.maxDHW + recent.meanDHW + DHW3 + DHW4 + DHW6 + DHW8 + DHW9 + rangeSST + varSST + MMM + GPS_S, data=adonis_meta_pver)
sort(vif.cca(ord_pver_full)) 
# according to vif.cca documentation, values over 10 indicate redundant constraints
    #      Depth           DHW6           DHW3  recent.maxDHW           DHW8         maxDHW           DHW9           DHW4        meanDHW       rangeSST 
    #   1.513119       8.139152       9.269449      10.521798      10.882881      15.392102      21.143380      30.863009      58.925047      65.211384 
    #     varSST          GPS_S recent.meanDHW            MMM 
    # 134.792127     188.566323     190.258298     418.940058

# Reduce the model (consult the corplot and vif scores)
ord_pver <- dbrda(dist_pver ~ Depth + DHW3 + DHW6 + recent.maxDHW + rangeSST + GPS_S, data=adonis_meta_pver)

# Re check the new vif scores
sort(vif.cca(ord_pver))
# Depth          DHW3          DHW6 recent.maxDHW         GPS_S      rangeSST 
#      1.101216      1.298297      1.520353      1.705474      1.722712      2.315683 

# Use ordistep to further refine the model
os_pver_backward <- ordistep(ord_pver, direction = "backward", trace = FALSE)
anova(os_pver_backward, by = 'margin')

pver_scores <- as.data.frame(scores(os_pver_backward, display = "sites")) %>%
  tibble::rownames_to_column(var = "plate_position") %>%
  left_join(., adonis_meta_pver %>% tibble::rownames_to_column(var = "plate_position"))

pver_vectors <- as.data.frame(os_pver_backward$CCA$biplot) %>%
  tibble::rownames_to_column(var = "factors")

ggplot(pver_scores, aes(x = dbRDA1, y = dbRDA2)) +
  geom_point(aes(fill = DHW3), size = 4, shape = 21) +
  #geom_encircle(aes(group = k), fill = "grey50", s_shape = 1, expand = 0, alpha = 0.2, show.legend = FALSE) +
  geom_text(data = pver_vectors, aes(x = dbRDA1, y = dbRDA2, label = factors), size = 4) +
  geom_segment(data = pver_vectors, aes(x = 0, xend = dbRDA1, y = 0, yend = dbRDA2), size = 0.5, arrow = arrow(length = unit(0.25, "cm")), colour = "grey") +
  theme(legend.position = "right", aspect.ratio = 1) +
  scale_fill_viridis_c(option = "magma")

plot(os_pver_backward)

#forward model does not take collinearity into account, as you can see by 7 predictors (many of which likely have high VIF scores)
#both will default to 'backward' if scope is not defined in model

```
```{r}
corrplot(cm_pver)
```


**P. meandrina** 
```{r}
#importing unifrac distances for analysis 
dist_pmea <- as.dist(du_pmea, diag = FALSE)
dim(du_pmea)

adonis_meta_pmea <- full_meta2 %>%
  dplyr::select(plate_position, Sector, Reef.x, Site, Species, 
                catBleaching, Depth, DHW, GPS_S = `GPS south`, 
                GPS_E = `GPS east`, Aspect, Exposure, maxDHW, 
                meanDHW, recent.maxDHW, recent.meanDHW, DHW2, 
                DHW3, DHW4, DHW6, DHW8, DHW9, returnDHW3, returnDHW4, 
                returnDHW6, rangeSST, varSST, MMM) %>%
  filter(plate_position %in% rownames(du_pmea)) %>%
  tibble::column_to_rownames(var = "plate_position") %>%
  mutate(sample_name = rownames(.))

# NOTE: Need to make sure there are no alias factors. E.g. exposure is an alias of Reef (e.g. all Marion = Exposed, Site and Reef contain aliases, DHW2 == DHW3, etc)

# Make a correlation matrix of numeric variables
cm <- cor(adonis_meta_pmea %>% select(Depth, maxDHW, meanDHW, recent.maxDHW, 
                                      recent.meanDHW, DHW3, DHW4, DHW6, DHW8, 
                                      DHW9, rangeSST, varSST, MMM, GPS_S))
library(corrplot)
corrplot(cm) # Clearly a lot of the DHW terms are positively related and approaching redundant

# Check the vif scores of the full model
ord_pmea_full <- dbrda(dist_pmea ~ Depth + maxDHW + meanDHW + recent.maxDHW + recent.meanDHW + DHW3 + DHW4 + DHW6 + DHW8 + DHW9 + rangeSST + varSST + MMM + GPS_S, data=adonis_meta_pmea)
sort(vif.cca(ord_pmea_full)) 
# Depth           DHW4           DHW6           DHW9           DHW8         maxDHW           DHW3  recent.maxDHW        meanDHW       rangeSST recent.meanDHW         varSST 
#       1.961623       5.524548       6.432968      10.005341      10.535683      11.883727      12.147581      13.755357      56.646502      67.138168     133.177017     155.900084 
#          GPS_S            MMM 
#     216.759822     414.329321  

# Reduce the model (consult the corplot and vif scores)
ord_pmea <- dbrda(dist_pmea ~ Depth + DHW3 + DHW6 + recent.maxDHW + rangeSST + GPS_S, data = adonis_meta_pmea)

# Re check the new vif scores
sort(vif.cca(ord_pmea))
# Depth          DHW3 recent.maxDHW      rangeSST          DHW6         GPS_S 
#      1.420261      1.550909      2.024239      2.425726      3.050987      3.653113 

# Use ordistep to further refine the model
os_pmea_backward <- ordistep(ord_pmea, direction = "backward")
anova(os_pmea_backward, by = 'margin')

pmea_scores <- as.data.frame(scores(os_pmea_backward, display = "sites")) %>%
  tibble::rownames_to_column(var = "plate_position") %>%
  left_join(., adonis_meta_pmea %>% tibble::rownames_to_column(var = "plate_position"))

pmea_vectors <- as.data.frame(os_pmea_backward$CCA$biplot) %>%
  tibble::rownames_to_column(var = "factors")

ggplot(pmea_scores, aes(x = dbRDA1, y = dbRDA2)) +
  geom_point(aes(fill = GPS_S), size = 4, shape = 21) +
  #ggalt::geom_encircle(aes(group = Reef.x), fill = "grey50", s_shape = 1, expand = 0, alpha = 0.2, show.legend = FALSE) +
  facet_wrap(~Reef.x) +
  geom_text(data = pmea_vectors, aes(x = dbRDA1, y = dbRDA2, label = factors), size = 4) +
  geom_segment(data = pmea_vectors, aes(x = 0, xend = dbRDA1, y = 0, yend = dbRDA2), size = 0.5, arrow = arrow(length = unit(0.25, "cm")), colour = "grey") +
  theme(legend.position = "right", aspect.ratio = 1) +
  scale_fill_viridis_c(option = "magma")

plot(os_pmea_backward)

#again, backward model seems to be the best option for narrowing down predictors AND ones that are not collinear
#both will default to 'backward' if scope is not defined in model
```
**A. humilis**

```{r}
#importing unifrac distances for analysis 
dist_acro <- as.dist(du_acro, diag = FALSE)
dim(du_acro)

adonis_meta_acro <- full_meta2 %>%
  dplyr::select(plate_position, Sector, Reef.x, Site, Species, 
                catBleaching, Depth, DHW, GPS_S = `GPS south`, 
                GPS_E = `GPS east`, Aspect, Exposure, maxDHW, 
                meanDHW, recent.maxDHW, recent.meanDHW, DHW2, 
                DHW3, DHW4, DHW6, DHW8, DHW9, returnDHW3, returnDHW4, 
                returnDHW6, rangeSST, varSST, MMM) %>%
  filter(plate_position %in% rownames(du_acro)) %>%
  tibble::column_to_rownames(var = "plate_position") %>%
  mutate(sample_name = rownames(.))

# NOTE: Need to make sure there are no alias factors. E.g. exposure is an alias of Reef (e.g. all Marion = Exposed, Site and Reef contain aliases, DHW2 == DHW3, etc)


# Make a correlation matrix of numeric variables
cm_acro <- cor(adonis_meta_acro %>% select(Depth, maxDHW, meanDHW, recent.maxDHW, 
                                      recent.meanDHW, DHW3, DHW4, DHW6, DHW8, 
                                      DHW9, rangeSST, varSST, MMM, GPS_S))
library(corrplot)
corrplot(cm_acro) # Clearly a lot of the DHW terms are positively related and approaching redundant

# Check the vif scores of the full model
ord_acro_full <- dbrda(dist_acro ~  Depth + maxDHW + meanDHW + recent.maxDHW + recent.meanDHW + DHW3 + DHW4 + DHW6 + DHW8 + DHW9 + rangeSST + varSST + MMM + GPS_S, data=adonis_meta_acro)
sort(vif.cca(ord_acro_full)) 
# according to vif.cca documentation, values over 10 indicate redundant constraints
    #  Depth           DHW6           DHW8           DHW3           DHW4           DHW9 
    #   1.602809       5.019220       6.170613       7.151695       8.330065      13.456450 
    #     maxDHW  recent.maxDHW        meanDHW recent.meanDHW       rangeSST         varSST 
    #  15.191953      15.506837      28.891993     113.987710     155.276867     179.948250 
    #      GPS_S            MMM 
    # 735.291524     780.690427 

# Reduce the model (consult the corplot and vif scores)
ord_acro <- dbrda(dist_acro ~ Depth + maxDHW + DHW3 + DHW6 + recent.maxDHW + rangeSST + GPS_S , data=adonis_meta_acro)

# Re check the new vif scores
sort(vif.cca(ord_acro))

# Use ordistep to further refine the model
os_acro_both <- ordistep(ord_acro, direction = "both", trace = FALSE)
anova(os_acro_both, by = 'margin')

os_acro_forward <- ordistep(ord_acro, direction = "forward", trace = FALSE)
anova(os_acro_forward, by = 'margin')

os_acro_backward <- ordistep(ord_acro, direction = "backward", trace = FALSE)
anova(os_acro_backward, by = 'margin')

plot(os_acro_both)
plot(os_acro_forward)
plot(os_acro_backward)

#again, backward model seems to be the best option for narrowing down predictors AND ones that are not collinear
#both will default to 'backward' if scope is not defined in model
```

# ----------------------------------------------------------
Permanova/ PCoA: **Pocillopora meandrina**
# ----------------------------------------------------------

## a Permanova/ Betadisper 
```{r}
dist_pmea <- as.dist(du_pmea, diag = FALSE)
dim(du_pmea)

adonis_meta_pmea <- full_meta2 %>%
  dplyr::select(plate_position, Sector, Reef.x, Site, Species, catBleaching, Depth, DHW, GPS_S = `GPS south`, GPS_E = `GPS east`, Aspect, Exposure, DHW3, DHW4, DHW6, DHW9, varSST) %>%
  filter(plate_position %in% rownames(du_pmea)) %>%
  tibble::column_to_rownames(var = "plate_position") %>%
  mutate(sample_name = rownames(.))

car::vif(lm(1:nrow(adonis_meta_pmea) ~ GPS_S  + catBleaching + Depth + DHW3, data=adonis_meta_pmea))


#dbRDA with all factors 
ord_pmea <- dbrda(dist_pmea ~ GPS_S + DHW3 + catBleaching + Depth, data = adonis_meta_pmea, permutations = 9999, scale = TRUE)
anova(ord_pmea, by = 'margin')   

#ordination plot 
ordplot_pmea <- plot(ord_pmea)
```





# ----------------------------------------------------------
Permanova/ PCoA: **Pocillopora unknown**
# ----------------------------------------------------------

Note: why is this plotting sample names instead of points?

```{r}
dist_punk <- as.dist(du_punk, diag = FALSE)

dim(du_punk)

adonis_meta_punk <- full_meta2 %>%
  dplyr::select(plate_position, Sector, Reef.x, Site, Species, catBleaching, Depth, DHW, GPS_S = `GPS south`, GPS_E = `GPS east`, Aspect, Exposure, DHW3, DHW4, DHW6, DHW9, varSST) %>%
  filter(plate_position %in% rownames(du_punk)) %>%
  tibble::column_to_rownames(var = "plate_position") %>%
  mutate(sample_name = rownames(.))

car::vif(lm(1:nrow(adonis_meta_punk) ~ GPS_S + DHW3 + catBleaching + Depth, data=adonis_meta_punk))

#dbRDA with all factors 
ord_punk <- dbrda(dist_punk ~ GPS_S + DHW3 + catBleaching + Depth, data = adonis_meta_punk, permutations = 9999)
anova(ord_punk, by = 'margin')   

#ordination plot 
ordplot_punk <- plot(ord_punk)
```

# ----------------------------------------------------------
Permanova/ PCoA: **Acropora humilis**
# ----------------------------------------------------------

PUT REEF AS A FACTOR HERE (refer to k-mer GUNIFRAC tree)
Note: cannot put reef as factor because VIF score = 5 (associated w DHW3 which is calculated per reef instead of GPS_S)

```{r}
dist_acro <- as.dist(du_acro, diag = FALSE)
dim(du_acro)

adonis_meta_acro <- full_meta2 %>%
  dplyr::select(plate_position, Sector, Reef.x, Site, Species, catBleaching, Depth, DHW, GPS_S = `GPS south`, GPS_E = `GPS east`, Aspect, Exposure, DHW3, DHW4, DHW6, DHW9, varSST) %>%
  filter(plate_position %in% rownames(du_acro)) %>%
  tibble::column_to_rownames(var = "plate_position") %>%
  mutate(sample_name = rownames(.))

car::vif(lm(1:nrow(adonis_meta_acro) ~ GPS_S + catBleaching + Depth + DHW3, data=adonis_meta_acro)) # REEF

#dbRDA with all factors 
ord_acro <- dbrda(dist_acro ~ GPS_S + varSST + catBleaching + Depth, data = adonis_meta_acro, permutations = 9999)
anova(ord_acro, by = 'margin')   

#ordination plot 
ordplot_acro <- plot(ord_acro)
```





```{r}
#dbrda 
ord <- dbrda(dist_pver ~ Exposure + Depth + DHW3 + GPS_S, data = adonis_meta_pver, permutations = 9999)
anova(ord, by = 'margin')    #indicates the marginal effect after controlling for the other variables.

#anova(ord, by = 'terms')     #analyses terms added sequentially. You get different significance because the terms are correlated, so which one goes into the model first determines how much variation is left to be explained by the second, or third... 

#capscale function for comparison 
ord2 <- capscale(dist_pver ~ Exposure + Depth + DHW3 + GPS_S, data = adonis_meta_pver, permutations = 9999)
anova(ord2, by = 'margin')

plot(ord2)


#use GVIF ^(1/2*df) to make comparable across dimensions, where df is the number of coefficients in the subset. This reduces GVIF to a linear measure, 

beta <- betadisper(dist_pver, adonis_meta_pver$GPS_S)
anova(beta)

plot(beta)

res.cap <- capscale(dist_pver ~ GPS_S + Aspect + Exposure + catBleaching + Depth + DHW, data = adonis_meta_pver)
(fit <- envfit(res.cap, adonis_meta_pver %>% select(GPS_S, Aspect, Exposure, catBleaching, Depth, DHW), perm = 999))

scores(fit, "vectors")
plot(res.cap)
plot(fit)
plot(fit, p.max = 0.05, col = "red")

res.cap <- capscale(dist_pver ~ GPS_S, data = adonis_meta_pver)

car::vif(res.cap)

permutest(res.cap)

res.ad
res.cap
plot(res.cap)
RsquareAdj(res.cap)

pca <- rda(elementome_rda)
eig <- eigenvals(res.cap)
eig <- data.frame(summary(eig))

test_pver <- betadisper(as.dist(du_pver), adonis_meta_pver$Reef)
plot(test_pver)
anova(test_pver)
```






**Hugo's code from Fukami lab tutorial**
## c. RDA P.ver

### MDS to explore the data
Let's quickly explore the data to see if any major patterns stand out.

Ideally, I think we should standardise the data in to proportion for each sample before picking the most abudant sequences
```{r}
# Load community matrix
load(file = "pver.community.matrix.RData")

my.symbionts = pver.community.matrix %>% summarise_all(mean, na.rm = T) %>% 
  gather() %>% 
  arrange(desc(value)) %>% 
  #ggplot(aes(y = value, x = key)) + geom_col()
  top_n(30) %>% pull(key)

# hellinger transform the species dataset: gives low weights to rare species 
spe.hel <- decostand(pver.community.matrix %>% select(all_of(my.symbionts)), "hellinger")

# Calculate distance matrix
bc<-vegdist(spe.hel, method="bray", binary=FALSE) 

# look at an unconstrained ordination first, it is always a good idea to look at both unconstrained and constrained ordinations
# set the seed: to reproduce the same result in the fture

bci.mds<-metaMDS(spe.hel, distance = "bray", k = 2, try = 60)

# extract x and y coordinates from MDS plot into new dataframe, so you can plot with ggplot 
MDS_xy <- data.frame(bci.mds$points) %>% 
  rownames_to_column() %>% 
  left_join(adonis_meta_pver %>% rownames_to_column(), by = "rowname") %>% 
  gather(key = variable, value = value, -c(rowname, MDS1, MDS2)) %>% 
  mutate(variable = as.factor(variable))
bci.mds$stress # 0.1241412

# plot
ggplot(MDS_xy, aes(MDS1, MDS2, col = value)) + 
  facet_wrap(~variable) +
  geom_point(alpha = .5) + 
  theme_bw() + 
  ggtitle(round(bci.mds$stress,2)) +
  theme(legend.position = "none")

```
It's not obsvious what might be driving community structure in these samples. 
Let's see if and of the predictors come out significant


```{r}
mdsvectors <- data.frame(bci.mds$species) %>% add_rownames("Species") %>%
  mutate(distance = sqrt((MDS1)^2 + (MDS2)^2))
  
mdspoints <- data.frame(scores(bci.mds))

ggplot()+
    geom_point(data=mdspoints, aes(x=NMDS1, y=NMDS2), col="white")+
    geom_segment(data=mdsvectors, aes(xend=0, yend=0, x=MDS1, y=MDS2), alpha = .6)+
    geom_segment(data=mdsvectors %>% top_n(8, distance), aes(xend=0, yend=0, x=MDS1, y=MDS2), alpha = 1) +
    geom_text(data=mdsvectors %>% top_n(8, distance), aes(x=MDS1, y=MDS2, label=Species), col="black", size=2.5, segment.colour = NA, box.padding = .2) +
   theme_classic()
```


### select traits
https://fukamilab.github.io/BIO202/06-B-constrained-ordination.html
```{r}
# create predictor data
# Check correlations, and avoid using predictors that are highly (un)correlated
library(corrplot)
adonis_meta_pver %>% 
  select(where(is.numeric)) %>%
cor %>%
corrplot(type = "upper", diag = F)
```
Reef and DHW and lat/long are aliases (interchangeable) 
lat/long are strongly correlated. we'll sector to represent geography



When one independent variable is highly correlated with another independent variable (or with a combination of independent variables), the marginal contribution of that independent variable is influenced by other predictor variables in the model. In this case, estimates for the regression coefficient of these variables can be unreliable or misleading.

To check for multicolinearity problem in our model, we need the vif() function from the car package. vif() calculates variance-inflation and generalized variance-inflation factors for linear, generalized linear, and other models. It measures how much the variance of any one of the coefficients is inflated due to multicollinearity in the overall model.

As a rule of thumb, a vif score over 5 is a problem. A score over 10 should be remedied and you should
consider dropping the problematic variable from the regression model or creating an index of all the closely related variables.
Note: 3 corresponds to an R-square of .6 so ideally we want values that is less than 3.

```{r}
# Estimate VIF and plot
library(car) #for variance inflation factors
#Check for variance inflation among key predictors
vif(lm(1:nrow(adonis_meta_pver) ~ Sector + Aspect + Exposure + catBleaching + Depth + DHW + DHW6, data=adonis_meta_pver))
```
Most our traits appear to be independent from one another (VIF score < 3 ) except for DHW and #events. We want to keep DHW but we can select one of DHW3,4,6,9 to represent bleaching history (I suggest DHW6).
Note I've remove geography (lat/long) as a predictor. If you were interested in this you would have to remove some predictors eg Sector and DHW.




We can  standardize the variables to zero mean and unit variance by adding argument scale = TRUE into the rda function. This standardisation ensures that each variable brings the same amount of variance into the analysis. This is important in the case that variables are each in very different units and have therefore very different variances.

```{r}
## Full model
RDAfull <- rda(pver.community.matrix %>% select(all_of(my.symbionts)) ~ Sector + Morphotype + Aspect + Exposure + catBleaching + Depth + DHW + DHW6,  data = adonis_meta_pver, scale = TRUE)

screeplot(RDAfull)
```
We can see that the first axis explains most of the variance in the data.


```{r}
# Test of all canonical axes
anova.cca(RDAfull, by='axis', step=99)

# canonical coefficients
as.data.frame(coef(RDAfull)) %>% rownames_to_column() %>% 
  select(rowname, RDA1) %>% arrange(desc(RDA1)) 
```
Only RDA1 is important.
          Df Variance      F Pr(>F)  
RDA1       1    6.737 4.6093  0.011 *


```{r}
summary(RDAfull)
```

Partitioning of correlations:
              Inertia Proportion
Total          40.000     1.0000
Constrained     6.229     0.1557
Unconstrained  33.771     0.8443

The *constrained* is the amount of variance the community matrix is explained by the explanatory variables (expressed as a proportion). Here, our predictors explain 15.6% of the data, and 84.4% of variance is unexplained (*unconstrained*). I suspect this is driven largely by 1 or 2 predictors.


```{r}
# adjusted R^2
R2adj <- RsquareAdj(RDAfull)$adj.r.squared
R2adj 
```
The adjusted R2 measures the unbiased amount of explained variation. So this model explains 4% of the variation in the data. If you used the biased R2, any variable included in the explanatory responses would increase the R2, so the R2 needs to be adjusted for the number of explanatory variables (especially since we have eight included here).


```{r}
plot(RDAfull, scaling=1, main="Triplot RDA matrix ~ env - scaling 1 - wa scores")

# arrows for species are missing, so lets add them without heads so they look different than the explanatory variables
spe.sc <- scores(RDAfull, choices=1:2, scaling=1, display="sp")
arrows(0,0,spe.sc[,1], spe.sc[,2], length=0, lty=1, col='red')
```




```{r}
## Model geography
pRDA1 <- rda(pver.community.matrix %>% select(all_of(my.symbionts)) ~ Sector + Aspect + Exposure + Depth + Condition(Morphotype  + catBleaching + DHW + DHW6),  data = adonis_meta_pver, scale = TRUE)
anova(pRDA1)
pRDA1
RsquareAdj(pRDA1)

## Model bleaching
pRDA2 <- rda(pver.community.matrix %>% select(all_of(my.symbionts)) ~ catBleaching + DHW + Condition(Sector + Morphotype + Aspect + Exposure + Depth + DHW6),  data = adonis_meta_pver, scale = TRUE)
anova(pRDA2)
pRDA2
RsquareAdj(pRDA2)

## Model climate history
pRDA3 <- rda(pver.community.matrix %>% select(all_of(my.symbionts)) ~ DHW6 + Condition(Sector + Morphotype + Aspect + Exposure + catBleaching + Depth + DHW),  data = adonis_meta_pver, scale = TRUE)
anova(pRDA3)
pRDA3
RsquareAdj(pRDA3)
```


**Other tests I don't want to delete yet** 

##b. PCoA 
```{r}
pcoares_pver <- pcoa(dist_pver)
            
pcoa_df_pver <- as.data.frame(pcoares_pver$vectors) %>%
  rownames_to_column(var = "plate_position") %>%
  dplyr::select(plate_position, Axis.1:Axis.5) %>% 
  left_join(., adonis_meta_pver %>% rownames_to_column(var = "plate_position")) %>%
    mutate(Reef = fct_relevel(Reef, c("Osprey", "Bougainville", "Moore", "Willis", "Holmes", "Chilcott", "Herald", "Lihou", "Flinders", "Marion", "Frederick", "Saumarez", "Wreck")))


ggplot(pcoa_df_pver, aes(Axis.1, Axis.2)) +
  geom_point(aes(fill = Reef), shape = 21, size = 3, alpha = 0.8) +
  facet_wrap(~Reef) +
  ggalt::geom_encircle(aes(group = Reef, fill = Reef), s_shape=1, expand=0, alpha = 0.1) 

#ggsave("fig/pcoa_df_poci.png", dpi =300, width=8, height=8, units = "cm")

```



#3c idea to plot the clustering, and colour by a factor **Pocillopora all species**
```{r}
library(reshape2)
k_poci <- kmeans(dist_pver, centers = 3)

kdf_poci <- enframe(k_poci$cluster) %>%
  select(name, k = value)

du_k_poci <- reshape2::melt(du_poci) %>%
        select(from = Var1, to = Var2, value) %>% 
          left_join(., kdf_poci, by = c("from" = "name")) %>%
            left_join(., kdf_poci, by = c("to" = "name"))

du_1_poci <- du_k_poci %>%
  filter(k.x == 2 & k.y == 2) %>%
  acast(from ~ to)

adonis_meta_poci <- full_meta2 %>%
  select(plate_position, Site, catBleaching, Species, Depth, DHW, GPS_S = `GPS south`, GPS_E = `GPS east`, Aspect, Exposure, Reef, DHW3, DHW4, DHW6, DHW9) %>%
  filter(plate_position %in% rownames(du_1_poci)) %>%
  tibble::column_to_rownames(var = "plate_position") %>%
  mutate(depth_cat = round(Depth))

adonis(du_ ~ Reef + Species, data = adonis_meta_poci)

pcoares_poci <- pcoa(du_1_poci)

pcoa_df_poci <- as.data.frame(pcoares_poci$vectors) %>%
  rownames_to_column(var = "plate_position") %>%
  left_join(., adonis_meta_poci %>% rownames_to_column(var = "plate_position"))

ggplot(pcoa_df_poci, aes(Axis.1, Axis.2)) +
  geom_point(aes(fill = Species), shape = 21, size = 3, alpha = 0.8) 
```



```{r}
# extract x and y coordinates from MDS plot into new dataframe, so you can plot with ggplot 
MDS_xy <- data.frame(bci.mds$points) %>% 
  rownames_to_column() %>% 
  left_join(adonis_meta_pver %>% rownames_to_column(), by = "rowname") %>% 
  gather(key = variable, value = value, -c(rowname, MDS1, MDS2)) %>% 
  mutate(variable = as.factor(variable))
bci.mds$stress # 0.1241412

# plot
ggplot(MDS_xy, aes(MDS1, MDS2, col = value)) + 
  facet_wrap(~variable) +
  geom_point(alpha = .5) + 
  theme_bw() + 
  ggtitle(round(bci.mds$stress,2)) +
  theme(legend.position = "none")
```


```{r}
pcoares_pver <- pcoa(du_pver)

pcoa_df_pver <- as.data.frame(pcoares_pver$vectors) %>%
  rownames_to_column(var = "plate_position") %>%
  left_join(., adonis_meta_pver %>% rownames_to_column(var = "plate_position"))

ggplot(pcoa_df_pver, aes(Axis.1, Axis.2)) +
  geom_point(aes(fill = catBleaching), shape = 21, size = 3, alpha = 0.8) 
```
